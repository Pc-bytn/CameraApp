<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Viewer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #343a40;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 500;
        }

        video {
            border: none;
            max-width: 100%;
            background-color: #333;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        input,
        button {
            padding: 10px 15px;
            margin: 5px;
            font-size: 0.95em;
            border-radius: 6px;
            border: 1px solid #ced4da;
            outline: none;
        }

        input {
            min-width: 250px;
            background-color: #fff;
        }

        button {
            background-color: #4682B4;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #3a6d99;
        }

        #connectionStatus {
            padding: 12px;
            margin: 15px 0;
            border-radius: 6px;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .connecting {
            background-color: #FFF3CD;
            color: #856404;
        }

        .connected {
            background-color: #D4EDDA;
            color: #155724;
        }

        .disconnected {
            background-color: #F8D7DA;
            color: #721C24;
        }

        #videoDebugInfo {
            margin-top: 15px;
            padding: 12px;
            background-color: #e9ecef;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #mediaControls button:disabled {
            background-color: #e2e6ea;
            color: #a0a5ab;
            cursor: not-allowed;
        }

        #clipsList,
        #screenshotsList {
            margin-top: 20px;
            padding: 15px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }

        #clipsList h3,
        #screenshotsList h3 {
            margin-top: 0;
            color: #2c3e50;
            font-weight: 500;
        }

        #clipsList ul,
        #screenshotsList ul {
            list-style-type: none;
            padding-left: 0;
        }

        #clipsList li,
        #screenshotsList li {
            background-color: #f9f9f9;
            border: 1px solid #eaeaea;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }

        #clipsList li:hover,
        #screenshotsList li:hover {
            background-color: #f3f4f6;
        }

        .media-item-info {
            flex-grow: 1;
            margin-right: 15px;
        }

        .media-item-info a {
            color: #3a80c5;
            text-decoration: none;
            word-break: break-all;
            font-weight: 500;
        }

        .media-item-info a:hover {
            text-decoration: underline;
        }

        .media-item-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .media-item-actions .rename-input {
            padding: 8px 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            width: 170px;
            font-size: 0.9em;
        }

        .media-item-actions button {
            padding: 8px 12px;
            border: none;
            background-color: #6c757d;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }

        .media-item-actions button:hover {
            background-color: #5a6268;
        }

        .media-item-actions button:disabled {
            background-color: #e9ecef;
            color: #adb5bd;
            cursor: not-allowed;
        }

        .media-item-actions .rename-button {
            background-color: #5cb85c;
        }

        .media-item-actions .rename-button:hover {
            background-color: #4cae4c;
        }

        .media-item-actions .upload-button {
            background-color: #428bca;
        }

        .media-item-actions .upload-button:hover {
            background-color: #3778b3;
        }

        .media-item-status {
            font-size: 0.9em;
            min-width: 100px;
            text-align: left;
            font-weight: 500;
        }

        .media-item-status.uploading {
            color: #007bff;
        }

        .media-item-status.uploaded {
            color: #28a745;
        }

        .media-item-status.failed {
            color: #dc3545;
        }

        /* Modern media controls section */
        #mediaControls {
            margin-top: 20px;
            padding: 18px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }

        #mediaControls button {
            min-width: 120px;
            text-align: center;
        }

        #startClipButton {
            background-color: #dc3545;
        }

        #startClipButton:hover {
            background-color: #c82333;
        }

        #endClipButton {
            background-color: #ffc107;
            color: #212529;
        }

        #endClipButton:hover {
            background-color: #e0a800;
        }

        #screenshotButton {
            background-color: #17a2b8;
        }

        #screenshotButton:hover {
            background-color: #138496;
        }

        #clipStatus {
            margin-left: 10px;
            font-style: italic;
            flex-grow: 1;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>WebRTC Stream Viewer / Host</h1>

        <div id="hostControls"
            style="margin-bottom: 20px; padding: 15px; background-color: #e9ecef; border-radius: 8px;">
            <h2>Host Session</h2>
            <button onclick="initiateHostSession()">Initiate New Host Session</button>
            <div id="hostSessionInfo" style="margin-top: 10px;"></div>
        </div>

        <div class="connection-controls">
            <input type="text" id="sessionIdInput" placeholder="Enter Session ID from App">
            <button onclick="joinStream()">Join Stream</button>
            <button onclick="stopViewing()">Stop Viewing</button>
        </div>
        <div id="connectionStatus" style="display: none;"></div>
        <video id="remoteVideo" autoplay playsinline controls muted></video>
        <div id="videoDebugInfo" style="display: none;"></div> <!-- Debug info for development -->

        <div id="mediaControls">
            <button id="startClipButton" onclick="startClip()" disabled>Start Clip</button>
            <button id="endClipButton" onclick="endClip()" disabled>End Clip</button>
            <button id="screenshotButton" onclick="takeScreenshot()" disabled>Screenshot</button>
            <span id="clipStatus"></span>
        </div>

        <div id="capturedMedia">
            <div id="clipsList" style="display: none;">
                <h3>Captured Clips</h3>
                <ul></ul>
            </div>
            <div id="screenshotsList" style="display: none;">
                <h3>Captured Screenshots</h3>
                <ul></ul>
            </div>
        </div>
    </div>

    <script src="PRIVATE_URL.JS"></script>
    <script>

        let peerConnection;
        const webSocketSignalingUrl = window.WEBSOCKET_SIGNALING_URL;
        let currentSessionId;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 3;
        let isReconnecting = false;
        let websocket;
        let keepAliveIntervalId;
        let reconnectTimeoutId = null;
        const RECONNECT_TIMEOUT = 15000; // 15 seconds timeout for reconnection attempts
        let isDebugMode = false; // Debug mode toggle
        let currentRole = 'viewer'; // Can be 'viewer' or 'host'

        let mediaRecorder;
        let recordedChunks = [];
        let streamStartTime;
        let clipStartTime;

        document.addEventListener('DOMContentLoaded', function () {
            const urlParams = new URLSearchParams(window.location.search);
            const sessionIdFromUrl = urlParams.get('sessionId');
            const roleFromUrl = urlParams.get('role'); // Check for role=host
            const debugParam = urlParams.get('debug');

            if (roleFromUrl === 'host') {
                currentRole = 'host';
                document.getElementById('hostControls').style.display = 'block';
                // Hide normal viewer join if role is host and no session ID yet
                if (!sessionIdFromUrl) {
                    document.querySelector('.connection-controls').style.display = 'none';
                }
            } else {
                currentRole = 'viewer';
                document.getElementById('hostControls').style.display = 'none';
            }

            // Initialize debug mode from URL parameter if present
            if (debugParam === '1' || debugParam === 'true') {
                isDebugMode = true;
                console.log('Debug mode enabled by URL parameter');
            }

            // Add keyboard shortcut for debug mode (Ctrl+Shift+D)
            document.addEventListener('keydown', function (e) {
                if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                    isDebugMode = !isDebugMode;
                    const debugElement = document.getElementById('videoDebugInfo');

                    if (isDebugMode) {
                        debugElement.style.display = 'block';
                        console.log('Debug mode enabled by keyboard shortcut');
                    } else {
                        debugElement.style.display = 'none';
                        console.log('Debug mode disabled by keyboard shortcut');
                    }

                    e.preventDefault();
                }
            });

            // Check browser compatibility
            checkMediaCompatibility();

            // Auto-join if session ID is in URL
            if (sessionIdFromUrl) {
                document.getElementById('sessionIdInput').value = sessionIdFromUrl;
                joinStream(); // Auto-join if sessionId is present (for both roles if applicable)
            }
        });

        const peerConnectionConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                {
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:openrelay.metered.ca:443',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ],
            iceCandidatePoolSize: 10
        };

        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.style.display = 'block';
            statusElement.textContent = message;
            statusElement.className = status;

            const connected = (status === 'connected');
            document.getElementById('startClipButton').disabled = !connected;
            document.getElementById('screenshotButton').disabled = !connected;

            // If host, and connected, ensure host controls remain visible
            if (currentRole === 'host') {
                document.getElementById('hostControls').style.display = 'block';
            }
        }

        function updateVideoDebugInfo(message) {
            // Always log to console regardless of debug mode
            console.log(`Video Debug: ${message}`);

            // Only update UI if debug mode is enabled
            if (isDebugMode) {
                const debugElement = document.getElementById('videoDebugInfo');
                const timestamp = new Date().toLocaleTimeString();
                debugElement.style.display = 'block';
                debugElement.innerHTML += `<p>${timestamp}: ${message}</p>`;
            }
        }

        function sendSignalingMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                message.sessionId = currentSessionId;
                // message.origin = 'viewer'; // Old: only viewer
                message.origin = currentRole; // 'viewer' or 'host'
                websocket.send(JSON.stringify(message));
                console.log(`Signaling message sent via WebSocket (${currentRole}):`, message.type);
                return true;
            } else {
                console.error(`WebSocket not connected, cannot send message (${currentRole}):`, message.type);
                updateConnectionStatus('disconnected', 'WebSocket not connected. Cannot send message.');
                return false;
            }
        }

        function connectWebSocketAndJoin() {
            if (websocket && (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING)) {
                console.log('WebSocket already connected or connecting.');
                return;
            }

            websocket = new WebSocket(webSocketSignalingUrl);

            websocket.onopen = () => {
                console.log(`WebSocket connection established (${currentRole}).`);
                updateConnectionStatus('connecting', 'WebSocket connected. Registering session...');
                websocket.send(JSON.stringify({
                    type: 'register',
                    sessionId: currentSessionId,
                    // peerType: 'viewer' // Old
                    peerType: currentRole // 'viewer' or 'host'
                }));

                if (keepAliveIntervalId) clearInterval(keepAliveIntervalId);
                keepAliveIntervalId = setInterval(() => {
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        sendSignalingMessage({ type: 'ping' });
                        console.log('Sending ping (viewer)');
                    }
                }, 25000);
            };

            websocket.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                console.log(`Received WebSocket message (${currentRole}):`, message);

                switch (message.type) {
                    case 'offer': // Offer comes from 'initiator' (Cordova app) or 'streamer' (browser)
                        if (message.offer) {
                            updateConnectionStatus('connecting', 'Offer received. Processing...');
                            await handleOffer(message.offer);
                            if (peerConnection && (peerConnection.iceConnectionState === 'connected' || peerConnection.iceConnectionState === 'completed')) {
                                document.getElementById('startClipButton').disabled = false;
                                document.getElementById('screenshotButton').disabled = false;
                            }
                        } else {
                            console.warn("Offer message received without offer data", message);
                        }
                        break;
                    case 'candidate':
                        if (peerConnection && message.candidate) {
                            if (peerConnection.remoteDescription) {
                                try {
                                    await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                                    console.log('Added remote ICE candidate (viewer).');
                                } catch (e) {
                                    console.error('Error adding received ICE candidate (viewer):', e);
                                }
                            } else {
                                console.warn('Received ICE candidate (viewer) but remote description not set yet.');
                            }
                        }
                        break;
                    case 'recovery_attempt':
                        updateConnectionStatus('connecting', 'Initiator is attempting to recover connection...');

                        // Reset timeout since initiator is actively working on it
                        if (reconnectTimeoutId) {
                            clearTimeout(reconnectTimeoutId);
                            reconnectTimeoutId = setTimeout(() => {
                                if (isReconnecting && peerConnection &&
                                    (peerConnection.iceConnectionState !== 'connected' &&
                                        peerConnection.iceConnectionState !== 'completed')) {
                                    updateConnectionStatus('disconnected', 'Recovery attempt timed out.');
                                }
                            }, RECONNECT_TIMEOUT);
                        }
                        break;
                    case 'hangup':
                        console.log(`Received hangup from ${message.origin || 'peer'}/server (${currentRole})`);
                        updateConnectionStatus('disconnected', `Stream ended by ${message.origin || 'peer'}.`);
                        stopViewing(false);
                        break;
                    case 'pong':
                        console.log(`Received pong from server (${currentRole}) - connection alive`);
                        break;
                    case 'error':
                        updateConnectionStatus('disconnected', `Server error: ${message.message}`);
                        console.error('Server error message:', message.message);
                        stopViewing(false);
                        break;
                    case 'session_not_found':
                        updateConnectionStatus('disconnected', `Session ID ${currentSessionId} not found or initiator/streamer not connected.`);
                        console.warn(`Session ${currentSessionId} not found or initiator/streamer not connected.`);
                        stopViewing(false);
                        break;
                    case 'streamer_connected': // Notification from server when streamer joins host's session
                        if (currentRole === 'host') {
                            updateConnectionStatus('connecting', 'Streamer has connected. Waiting for their video offer...');
                            // Host doesn't send offer, it waits for streamer's offer.
                        }
                        break;
                }
            };

            websocket.onerror = (error) => {
                console.error(`WebSocket error (${currentRole}):`, error);
                updateConnectionStatus('disconnected', 'WebSocket connection error. Please try again.');
                stopViewing(false);
            };

            websocket.onclose = (event) => {
                console.log(`WebSocket connection closed (${currentRole}):`, event.reason, `Code: ${event.code}`);
                if (keepAliveIntervalId) clearInterval(keepAliveIntervalId);
                // updateConnectionStatus('disconnected', 'Disconnected from signaling server.'); // Already handled by stopViewing or specific error
            };
        }

        async function joinStream() { // Used by original viewer and host (after initiating)
            currentSessionId = document.getElementById('sessionIdInput').value.trim();
            if (!currentSessionId) {
                alert('Please enter a Session ID.');
                return;
            }
            // if (peerConnection && peerConnection.iceConnectionState !== 'closed' && peerConnection.iceConnectionState !== 'failed') {
            //     alert('Already connected or attempting to connect. Please "Stop Viewing" first.');
            //     return;
            // }

            if (websocket && websocket.readyState === WebSocket.OPEN) {
                // If trying to join a new session, close the old one first.
                // This is more relevant if the user manually changes session ID and clicks join again.
                stopViewing(true); // Notify server about leaving old session
            }
            // Ensure peerConnection is reset if joining a new stream
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }


            updateConnectionStatus('connecting', `Attempting to join stream for session ${currentSessionId} as ${currentRole}...`);
            reconnectAttempts = 0;
            isReconnecting = false;

            connectWebSocketAndJoin(); // This will register with the new currentSessionId and currentRole
        }

        async function handleOffer(offer) {
            if (peerConnection) {
                peerConnection.close();
            }
            peerConnection = new RTCPeerConnection(peerConnectionConfig);

            // Add debug tracking
            updateVideoDebugInfo("PeerConnection created, waiting for tracks...");

            peerConnection.ontrack = event => {
                updateVideoDebugInfo(`Track received: ${event.track.kind}`);
                const remoteVideo = document.getElementById('remoteVideo');

                // Ensure the video is ready to play
                remoteVideo.onloadedmetadata = () => {
                    updateVideoDebugInfo("Video metadata loaded, attempting to play");
                    remoteVideo.play()
                        .then(() => updateVideoDebugInfo("Video playback started successfully"))
                        .catch(e => {
                            updateVideoDebugInfo(`Error starting video: ${e.message}`);
                            alert('Error playing video. Try clicking on the video to unmute/play.');
                        });
                };

                remoteVideo.onerror = (e) => {
                    updateVideoDebugInfo(`Video element error: ${e.message || 'Unknown error'}`);
                };

                if (event.streams && event.streams[0]) {
                    updateVideoDebugInfo("Using stream from event.streams[0]");
                    remoteVideo.srcObject = event.streams[0];
                    // updateConnectionStatus('connected', 'Stream connected successfully!'); // Moved to oniceconnectionstatechange
                    // reconnectAttempts = 0;
                    // isReconnecting = false;
                } else if (event.track) {
                    updateVideoDebugInfo("No stream available, creating new MediaStream");
                    if (!remoteVideo.srcObject) {
                        remoteVideo.srcObject = new MediaStream();
                    }
                    remoteVideo.srcObject.addTrack(event.track);
                    // updateConnectionStatus('connected', 'Stream connected successfully!'); // Moved to oniceconnectionstatechange
                    // reconnectAttempts = 0;
                    // isReconnecting = false;
                }

                // Enable controls once the track is received and video is playing
                remoteVideo.oncanplay = () => {
                    document.getElementById('startClipButton').disabled = false;
                    document.getElementById('screenshotButton').disabled = false;
                    updateVideoDebugInfo('Video can play, media controls enabled.');
                };
            };

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    sendSignalingMessage({ type: 'candidate', candidate: event.candidate });
                    updateVideoDebugInfo("ICE candidate sent to initiator");
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log(`ICE connection state (${currentRole}): ${peerConnection.iceConnectionState}`);
                updateVideoDebugInfo(`ICE connection state: ${peerConnection.iceConnectionState}`);

                if (peerConnection.iceConnectionState === 'connected' || peerConnection.iceConnectionState === 'completed') {
                    updateConnectionStatus('connected', 'Stream connected successfully!');
                    reconnectAttempts = 0;
                    isReconnecting = false;
                    if (currentRole === 'host') { // Ensure host controls are visible and updated
                        document.getElementById('hostControls').style.display = 'block';
                    }
                } else if (peerConnection.iceConnectionState === 'failed') {
                    updateConnectionStatus('disconnected', 'Stream connection failed.');
                    handleConnectionFailure();
                } else if (peerConnection.iceConnectionState === 'disconnected') {
                    updateConnectionStatus('connecting', 'Stream temporarily disconnected. Attempting to recover...');
                } else if (peerConnection.iceConnectionState === 'closed') {
                    updateConnectionStatus('disconnected', 'Stream closed.');
                }
            };

            peerConnection.onsignalingstatechange = () => {
                console.log(`Signaling state (${currentRole}): ${peerConnection.signalingState}`);
            };

            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                console.log('Remote description (offer) set.');
                updateVideoDebugInfo("Remote description (offer) set successfully");

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Local description (answer) created.');
                updateVideoDebugInfo("Local description (answer) created successfully");

                const sendSuccess = sendSignalingMessage({ type: 'answer', answer: answer });
                if (!sendSuccess) {
                    updateConnectionStatus('disconnected', 'Failed to send answer. Please try again.');
                    throw new Error('Failed to send answer via WebSocket.');
                }
            } catch (error) {
                updateVideoDebugInfo(`Error in offer/answer process: ${error.message}`);
                console.error("WebRTC error:", error);
                updateConnectionStatus('disconnected', `WebRTC Error: ${error.message}`);
            }
        }

        function handleConnectionFailure() {
            if (isReconnecting) return;

            isReconnecting = true;
            reconnectAttempts++;

            if (reconnectAttempts <= MAX_RECONNECT_ATTEMPTS) {
                updateConnectionStatus('connecting', `WebRTC connection failed. Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);

                if (reconnectTimeoutId) {
                    clearTimeout(reconnectTimeoutId);
                }

                // Request ICE restart from initiator/streamer
                sendSignalingMessage({ type: 'request_ice_restart' }); // Sent to 'initiator' or 'streamer'
                console.log(`WebRTC connection failed. ${currentRole} is requesting ICE restart.`);

                // Set timeout for this reconnection attempt
                reconnectTimeoutId = setTimeout(() => {
                    if (isReconnecting && peerConnection &&
                        (peerConnection.iceConnectionState !== 'connected' &&
                            peerConnection.iceConnectionState !== 'completed')) {

                        updateConnectionStatus('disconnected', `Reconnect attempt ${reconnectAttempts} timed out.`);
                        sendSignalingMessage({ type: 'recovery_timeout' });

                        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                            updateConnectionStatus('disconnected', 'Failed to reconnect after multiple attempts.');
                            stopViewing(false);
                        } else {
                            // Try again with a new connection
                            if (peerConnection) {
                                peerConnection.close();
                                peerConnection = null;
                            }
                            // Wait briefly before attempting again
                            setTimeout(() => {
                                isReconnecting = false;
                                handleConnectionFailure();
                            }, 2000);
                        }
                    }
                }, RECONNECT_TIMEOUT);
            } else {
                updateConnectionStatus('disconnected', 'Failed to reconnect WebRTC stream after multiple attempts.');
                console.error('Failed to reconnect WebRTC stream.');
                stopViewing(false);
            }
        }

        function stopViewing(notifyServer = true) {
            if (keepAliveIntervalId) {
                clearInterval(keepAliveIntervalId);
                keepAliveIntervalId = null;
            }

            if (notifyServer && websocket && websocket.readyState === WebSocket.OPEN && currentSessionId) {
                sendSignalingMessage({ type: 'hangup' });
                console.log(`Sent hangup message via WebSocket (${currentRole}).`);
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (websocket) {
                if (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING) {
                    websocket.onclose = null;
                    websocket.close();
                }
                websocket = null;
            }

            const remoteVideo = document.getElementById('remoteVideo');
            if (remoteVideo) remoteVideo.srcObject = null;
            updateConnectionStatus('disconnected', 'Viewing stopped.');
            document.getElementById('connectionStatus').style.display = 'block';
            isReconnecting = false;
            reconnectAttempts = 0;

            document.getElementById('startClipButton').disabled = true;
            document.getElementById('endClipButton').disabled = true;
            document.getElementById('screenshotButton').disabled = true;
            document.getElementById('clipStatus').textContent = '';

            // For host, reset host UI elements if needed
            if (currentRole === 'host') {
                // document.getElementById('hostSessionInfo').innerHTML = ''; // Clear session info
                // document.querySelector('.connection-controls').style.display = 'none'; // Hide viewer join
            }

            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
            }
        }

        function checkMediaCompatibility() {
            updateVideoDebugInfo(`Browser: ${navigator.userAgent}`);
            if (navigator.mediaDevices) {
                updateVideoDebugInfo("mediaDevices API available");
            } else {
                updateVideoDebugInfo("mediaDevices API NOT available");
            }

            if (window.RTCPeerConnection) {
                updateVideoDebugInfo("RTCPeerConnection API available");
            } else {
                updateVideoDebugInfo("RTCPeerConnection API NOT available");
            }

            if (window.MediaStream) {
                updateVideoDebugInfo("MediaStream API available");
            } else {
                updateVideoDebugInfo("MediaStream API NOT available");
            }

            // Apply appropriate display setting based on debug mode
            const debugElement = document.getElementById('videoDebugInfo');
            debugElement.style.display = isDebugMode ? 'block' : 'none';
        }

        // FR008 & FR010: Viewer Live Clipping and Media Controls
        function startClip() {
            const remoteVideo = document.getElementById('remoteVideo');
            if (!remoteVideo.srcObject || remoteVideo.readyState < remoteVideo.HAVE_METADATA) { // Check readyState
                alert('Stream not available or not ready to start clipping.');
                updateVideoDebugInfo('Attempted to start clip, but no stream available or not ready.');
                return;
            }

            if (mediaRecorder && mediaRecorder.state === "recording") {
                alert('Clipping is already in progress.');
                return;
            }

            try {
                const stream = remoteVideo.srcObject;
                recordedChunks = []; // Reset for new clip
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstart = () => {
                    clipStartTime = new Date();
                    document.getElementById('startClipButton').disabled = true;
                    document.getElementById('endClipButton').disabled = false;
                    document.getElementById('screenshotButton').disabled = true; // Disable screenshot during clipping
                    document.getElementById('clipStatus').textContent = 'Clipping in progress...';
                    updateVideoDebugInfo('Clipping started.');
                    console.log('MediaRecorder started, state:', mediaRecorder.state);
                };

                mediaRecorder.onstop = () => {
                    document.getElementById('startClipButton').disabled = false;
                    document.getElementById('endClipButton').disabled = true;
                    document.getElementById('screenshotButton').disabled = false; // Re-enable screenshot
                    document.getElementById('clipStatus').textContent = 'Clip captured!';
                    updateVideoDebugInfo('Clipping stopped. Processing data...');
                    console.log('MediaRecorder stopped, state:', mediaRecorder.state);

                    if (recordedChunks.length === 0) {
                        console.warn("No data recorded for the clip.");
                        alert("No data was recorded for the clip. Please try again.");
                        document.getElementById('clipStatus').textContent = 'Clip capture failed (no data).';
                        return;
                    }

                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const clipName = `clip_${new Date().toISOString().replace(/[:.]/g, '-')}.webm`;

                    addMediaToList('clipsList', clipName, url, blob);
                    recordedChunks = []; // Clear for next recording

                    setTimeout(() => {
                        document.getElementById('clipStatus').textContent = '';
                    }, 3000);
                };

                mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                    alert('Error during clipping: ' + event.error.name);
                    document.getElementById('startClipButton').disabled = false;
                    document.getElementById('endClipButton').disabled = true;
                    document.getElementById('screenshotButton').disabled = false;
                    document.getElementById('clipStatus').textContent = 'Clipping error.';
                    updateVideoDebugInfo(`MediaRecorder error: ${event.error.name} - ${event.error.message}`);
                };

                mediaRecorder.start();

            } catch (e) {
                console.error('Error starting MediaRecorder:', e);
                alert('Could not start clipping: ' + e.message);
                updateVideoDebugInfo(`Error starting MediaRecorder: ${e.message}`);
                document.getElementById('startClipButton').disabled = false;
                document.getElementById('endClipButton').disabled = true;
                document.getElementById('screenshotButton').disabled = false;
            }
        }

        function endClip() {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop(); // This will trigger the 'dataavailable' event one last time, then 'stop'
                document.getElementById('startClipButton').disabled = false;
                document.getElementById('endClipButton').disabled = true;
                document.getElementById('clipStatus').textContent = 'Clip captured. Processing...';
            }
        }

        // FR009 & FR010: Viewer Screenshot Capture and Media Controls
        function takeScreenshot() {
            const remoteVideo = document.getElementById('remoteVideo');
            if (!remoteVideo.srcObject || remoteVideo.paused || remoteVideo.ended) {
                alert('Video stream not active or available for screenshot.');
                updateVideoDebugInfo('Screenshot attempt failed: Video stream not active.');
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = remoteVideo.videoWidth;
            canvas.height = remoteVideo.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(remoteVideo, 0, 0, canvas.width, canvas.height);

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const fileName = `screenshot-${timestamp}.png`;

            canvas.toBlob(function (blob) {
                const dataUrl = URL.createObjectURL(blob);
                addMediaToList('screenshotsList', fileName, dataUrl, blob); // Pass blob
                document.getElementById('clipStatus').textContent = `Screenshot ${fileName} captured.`;
            }, 'image/png');
        }

        function addMediaToList(listId, fileName, dataUrl, blob) { // Added blob parameter
            const list = document.getElementById(listId).querySelector('ul');
            const listItem = document.createElement('li');

            const mediaInfoDiv = document.createElement('div');
            mediaInfoDiv.classList.add('media-item-info');

            const link = document.createElement('a');
            link.href = dataUrl;
            link.textContent = fileName;
            link.download = fileName;
            mediaInfoDiv.appendChild(link);

            listItem.appendChild(mediaInfoDiv);

            // FR010 & FR011: Add Rename and Upload controls
            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('media-item-actions');

            const renameInput = document.createElement('input');
            renameInput.type = 'text';
            renameInput.value = fileName.substring(0, fileName.lastIndexOf('.')); // Default name without extension
            renameInput.style.display = 'none'; // Initially hidden
            renameInput.classList.add('rename-input');

            const renameButton = document.createElement('button');
            renameButton.textContent = 'Rename';
            renameButton.classList.add('rename-button');
            renameButton.onclick = () => {
                if (renameButton.textContent === 'Rename') {
                    link.style.display = 'none';
                    renameInput.style.display = 'inline-block';
                    renameInput.focus();
                    renameButton.textContent = 'Save';
                } else {
                    const newNameBase = renameInput.value.trim();
                    const extension = fileName.substring(fileName.lastIndexOf('.'));
                    if (newNameBase) {
                        const newFileName = newNameBase + extension;
                        link.textContent = newFileName;
                        link.download = newFileName;
                    }
                    link.style.display = 'inline-block';
                    renameInput.style.display = 'none';
                    renameButton.textContent = 'Rename';
                }
            };

            const uploadButton = document.createElement('button');
            uploadButton.textContent = 'Upload';
            uploadButton.classList.add('upload-button');

            const itemStatusSpan = document.createElement('span'); // Item-specific status
            itemStatusSpan.classList.add('media-item-status');
            itemStatusSpan.style.marginLeft = '10px';

            uploadButton.onclick = async () => { // Make it async to use await
                itemStatusSpan.textContent = 'Uploading...';
                uploadButton.disabled = true;
                renameButton.disabled = true;
                try {
                    // Use link.download as it reflects the current (potentially renamed) filename
                    const success = await uploadMedia(link.download, blob, currentSessionId, itemStatusSpan);
                    if (success) {
                        itemStatusSpan.textContent = 'Uploaded!';
                        uploadButton.textContent = 'Uploaded';
                        // uploadButton.disabled = true; // Already disabled, and stays disabled
                    } else {
                        itemStatusSpan.textContent = 'Upload Failed.';
                        uploadButton.disabled = false; // Re-enable to try again
                        renameButton.disabled = false;
                    }
                } catch (e) {
                    itemStatusSpan.textContent = 'Upload Error.';
                    uploadButton.disabled = false; // Re-enable to try again
                    renameButton.disabled = false;
                }
            };

            actionsDiv.appendChild(renameButton);
            actionsDiv.appendChild(renameInput);
            actionsDiv.appendChild(uploadButton);
            actionsDiv.appendChild(itemStatusSpan); // Add item status display
            listItem.appendChild(actionsDiv);

            list.appendChild(listItem);
            document.getElementById(listId).style.display = 'block';
        }

        // FR011: Function to upload media
        // Modified to return a boolean for success and accept an itemStatusElement
        async function uploadMedia(fileName, blob, sessionId, itemStatusElement) {
            const globalStatusElement = document.getElementById('clipStatus'); // General status

            if (!blob) {
                const msg = 'No media data to upload.';
                if (itemStatusElement) { itemStatusElement.textContent = msg; itemStatusElement.className = 'media-item-status failed'; }
                else if (globalStatusElement) globalStatusElement.textContent = msg;
                alert(msg);
                console.error('Upload error: Blob is undefined for', fileName);
                return false;
            }
            if (!sessionId) {
                const msg = 'Session ID is missing. Cannot upload.';
                if (itemStatusElement) { itemStatusElement.textContent = msg; itemStatusElement.className = 'media-item-status failed'; }
                else if (globalStatusElement) globalStatusElement.textContent = msg;
                alert(msg);
                console.error('Upload error: Session ID is missing.');
                return false;
            }

            const formData = new FormData();
            formData.append('mediaFile', blob, fileName);
            formData.append('sessionId', sessionId);
            formData.append('fileName', fileName);

            if (itemStatusElement) { itemStatusElement.textContent = `Uploading ${fileName}...`; itemStatusElement.className = 'media-item-status uploading'; }
            else if (globalStatusElement) globalStatusElement.textContent = `Uploading ${fileName}...`;

            try {
                const response = await fetch('upload.php', {
                    method: 'POST',
                    body: formData
                });

                const resultText = await response.text();
                console.log('Upload response text:', resultText);

                if (response.ok) {
                    const result = JSON.parse(resultText);
                    if (result.success) {
                        const msg = `${fileName} uploaded.`;
                        if (itemStatusElement) { itemStatusElement.textContent = msg; itemStatusElement.className = 'media-item-status uploaded'; }
                        else if (globalStatusElement) globalStatusElement.textContent = `${fileName} uploaded successfully!`;
                        console.log('Upload successful:', result.message);
                        return true;
                    } else {
                        const msg = `Upload failed: ${result.message || 'Unknown server error'}`;
                        if (itemStatusElement) { itemStatusElement.textContent = msg; itemStatusElement.className = 'media-item-status failed'; }
                        else if (globalStatusElement) globalStatusElement.textContent = msg;
                        alert(`Upload failed for ${fileName}: ${result.message || 'Unknown server error'}`);
                        console.error('Upload failed:', result.message);
                        return false;
                    }
                } else {
                    const msg = `Server error: ${response.statusText}`;
                    if (itemStatusElement) { itemStatusElement.textContent = msg; itemStatusElement.className = 'media-item-status failed'; }
                    else if (globalStatusElement) globalStatusElement.textContent = `Upload failed for ${fileName}: ${response.statusText} - ${resultText}`;
                    alert(`Upload failed for ${fileName}: ${response.statusText} - ${resultText}`);
                    console.error('Upload server error:', response.status, response.statusText, resultText);
                    return false;
                }
            } catch (error) {
                const msg = `Error: ${error.message.substring(0, 30)}${error.message.length > 30 ? '...' : ''}`;
                if (itemStatusElement) { itemStatusElement.textContent = msg; itemStatusElement.className = 'media-item-status failed'; }
                else if (globalStatusElement) globalStatusElement.textContent = `Error uploading ${fileName}: ${error.message}`;
                alert(`Error uploading ${fileName}: ${error.message}`);
                console.error('Upload fetch error:', error);
                return false;
            } finally {
                setTimeout(() => {
                    if (globalStatusElement && (globalStatusElement.textContent.startsWith(`Uploading ${fileName}`) || globalStatusElement.textContent.startsWith(`${fileName} uploaded`))) {
                        globalStatusElement.textContent = '';
                    }
                }, 3000);
            }
        }

        // --- New Host Functionality for FR012 ---
        function generateUniqueId() {
            return Math.random().toString(36).substring(2, 15);
        }

        async function initiateHostSession() {
            updateConnectionStatus('connecting', 'Checking server status...');
            
            // Check if WebSocket and Nginx servers are running
            let wsServerReady = false;
            let nginxServerReady = false;
            let serverCheckResult = null;
            let maxAttempts = 5;
            let attempt = 0;
            
            while ((!wsServerReady || !nginxServerReady) && attempt < maxAttempts) {
                try {
                    const serverCheckResponse = await fetch('StartServers.php');
                    serverCheckResult = await serverCheckResponse.json();
                    
                    // Check WebSocket server status
                    if (serverCheckResult.running) {
                        wsServerReady = true;
                        updateVideoDebugInfo('WebSocket server is running');
                        if (serverCheckResult.started) {
                            updateVideoDebugInfo('WebSocket server started successfully');
                        }
                    }
                    
                    // Check Nginx server status
                    if (serverCheckResult.nginx_running) {
                        nginxServerReady = true;
                        updateVideoDebugInfo('Nginx server is running');
                        if (serverCheckResult.nginx_started) {
                            updateVideoDebugInfo('Nginx server started successfully');
                        }
                    }
                    
                    // If both servers are ready, we can break the loop
                    if (wsServerReady && nginxServerReady) {
                        break;
                    }
                } catch (err) {
                    console.error('Error checking server status:', err);
                    updateVideoDebugInfo(`Server check error: ${err.message}`);
                }
                attempt++;
                if (attempt < maxAttempts) {
                    updateVideoDebugInfo(`Retrying server check (attempt ${attempt+1}/${maxAttempts})...`);
                    await new Promise(res => setTimeout(res, 1000)); // Wait 1 second before retry
                }
            }

            // Handle server status
            if (!wsServerReady && !nginxServerReady) {
                updateConnectionStatus('disconnected', 'Both WebSocket and Nginx servers are not running and could not be started.');
                alert('Both WebSocket and Nginx servers are not running. Cannot start host session.');
                return;
            } else if (!wsServerReady) {
                updateConnectionStatus('disconnected', 'WebSocket server is not running and could not be started.');
                alert('WebSocket server is not running. Cannot start host session.');
                return;
            } else if (!nginxServerReady) {
                updateVideoDebugInfo('Warning: Nginx server is not running.');
                return;
            }
            
            // Now proceed with setting up the host session
            currentRole = 'host'; // Explicitly set role
            currentSessionId = generateUniqueId();
            document.getElementById('sessionIdInput').value = currentSessionId; // Populate for potential re-join

            const hostSessionInfoDiv = document.getElementById('hostSessionInfo');
            const baseAppUrl = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));
            const streamerLink = `${baseAppUrl}/stream.html?sessionId=${currentSessionId}`;

            hostSessionInfoDiv.innerHTML =
                `New Session ID: <strong>${currentSessionId}</strong><br>` +
                `Share this link: <input type="text" value="${streamerLink}" id="streamerLinkInput" readonly style="width:80%; margin:5px 0;">` +
                `<button onclick="copyLink('streamerLinkInput')">Copy Link</button><br>`;

            document.querySelector('.connection-controls').style.display = 'block'; // Show connection controls for host to "join" their own session as viewer
            document.getElementById('hostControls').style.display = 'block';

            // Automatically "join" the stream as host to listen for the streamer
            joinStream();
        }

        function copyLink(inputId) {
            const inputElement = document.getElementById(inputId);
            inputElement.select();
            inputElement.setSelectionRange(0, 99999); // For mobile devices
            try {
                document.execCommand('copy');
                alert('Link copied to clipboard!');
            } catch (err) {
                alert('Failed to copy link. Please copy it manually.');
            }
        }

    </script>
</body>

</html>