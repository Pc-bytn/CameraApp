<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Stream Viewer</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        video { border: 1px solid black; max-width: 100%; background-color: #333; }
        input, button { padding: 10px; margin: 5px; font-size: 1em; }
        #connectionStatus {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .connecting { background-color: #FFF3CD; color: #856404; }
        .connected { background-color: #D4EDDA; color: #155724; }
        .disconnected { background-color: #F8D7DA; color: #721C24; }
        #videoDebugInfo {
            margin-top: 10px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
        #mediaControls button:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
        }
        #clipsList, #screenshotsList {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        #clipsList h3, #screenshotsList h3 {
            margin-top: 0;
        }
        #clipsList ul, #screenshotsList ul {
            list-style-type: none;
            padding-left: 0;
        }
        #clipsList li, #screenshotsList li {
            margin-bottom: 5px;
        }
        #clipsList a, #screenshotsList a {
            text-decoration: none;
            color: #007bff;
        }
        #clipsList a:hover, #screenshotsList a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>WebRTC Stream Viewer</h1>
    <div>
        <input type="text" id="sessionIdInput" placeholder="Enter Session ID from App">
        <button onclick="joinStream()">Join Stream</button>
        <button onclick="stopViewing()">Stop Viewing</button>
    </div>
    <div id="connectionStatus" style="display: none;"></div>
    <video id="remoteVideo" autoplay playsinline controls muted></video>
    <div id="videoDebugInfo" style="display: none;"></div>

    <div id="mediaControls" style="margin-top: 15px;">
        <button id="startClipButton" onclick="startClip()" disabled>Start Clip</button>
        <button id="endClipButton" onclick="endClip()" disabled>End Clip</button>
        <button id="screenshotButton" onclick="takeScreenshot()" disabled>Screenshot</button>
        <span id="clipStatus" style="margin-left: 10px; font-style: italic;"></span>
    </div>

    <div id="capturedMedia" style="margin-top: 20px;">
        <div id="clipsList" style="display: none;">
            <h3>Captured Clips:</h3>
            <ul></ul>
        </div>
        <div id="screenshotsList" style="display: none;">
            <h3>Captured Screenshots:</h3>
            <ul></ul>
        </div>
    </div>
    
    <script src="PRIVATE_URL.JS"></script>
    <script>
        let peerConnection;
        const webSocketSignalingUrl = window.WEBSOCKET_SIGNALING_URL;
        let currentSessionId;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 3;
        let isReconnecting = false;
        let websocket;
        let keepAliveIntervalId;
        let reconnectTimeoutId = null;
        const RECONNECT_TIMEOUT = 15000; // 15 seconds timeout for reconnection attempts

        let mediaRecorder;
        let recordedChunks = [];
        let streamStartTime;
        let clipStartTime;

        document.addEventListener('DOMContentLoaded', function() {
            const urlParams = new URLSearchParams(window.location.search);
            const sessionIdFromUrl = urlParams.get('sessionId');
            
            // Check browser compatibility
            checkMediaCompatibility();
            
            // Auto-join if session ID is in URL
            if (sessionIdFromUrl) {
                document.getElementById('sessionIdInput').value = sessionIdFromUrl;
                joinStream();
            }
        });

        const peerConnectionConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                {
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:openrelay.metered.ca:443',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ],
            iceCandidatePoolSize: 10
        };

        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.style.display = 'block';
            statusElement.textContent = message;
            statusElement.className = status;

            // Enable/disable media controls based on connection status
            const connected = (status === 'connected');
            document.getElementById('startClipButton').disabled = !connected;
            // endClipButton is handled by startClip/endClip logic
            document.getElementById('screenshotButton').disabled = !connected;
        }

        function updateVideoDebugInfo(message) {
            const debugElement = document.getElementById('videoDebugInfo');
            const timestamp = new Date().toLocaleTimeString();
            debugElement.style.display = 'block';
            debugElement.innerHTML += `<p>${timestamp}: ${message}</p>`;
            console.log(`Video Debug: ${message}`);
        }

        function sendSignalingMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                message.sessionId = currentSessionId;
                message.origin = 'viewer';
                websocket.send(JSON.stringify(message));
                console.log('Signaling message sent via WebSocket (viewer):', message.type);
                return true;
            } else {
                console.error('WebSocket not connected, cannot send message (viewer):', message.type);
                updateConnectionStatus('disconnected', 'WebSocket not connected. Cannot send message.');
                return false;
            }
        }

        function connectWebSocketAndJoin() {
            if (websocket && (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING)) {
                console.log('WebSocket already connected or connecting.');
                return;
            }

            websocket = new WebSocket(webSocketSignalingUrl);

            websocket.onopen = () => {
                console.log('WebSocket connection established (viewer).');
                updateConnectionStatus('connecting', 'WebSocket connected. Registering session...');
                websocket.send(JSON.stringify({
                    type: 'register',
                    sessionId: currentSessionId,
                    peerType: 'viewer'
                }));

                if (keepAliveIntervalId) clearInterval(keepAliveIntervalId);
                keepAliveIntervalId = setInterval(() => {
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        sendSignalingMessage({ type: 'ping' });
                        console.log('Sending ping (viewer)');
                    }
                }, 25000);
            };

            websocket.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                console.log('Received WebSocket message (viewer):', message);

                switch (message.type) {
                    case 'offer':
                        if (message.offer) {
                            updateConnectionStatus('connecting', 'Offer received. Processing...');
                            await handleOffer(message.offer);
                            // Enable buttons once the stream is likely to be active
                            if (peerConnection && peerConnection.iceConnectionState === 'connected' || peerConnection.iceConnectionState === 'completed') {
                                document.getElementById('startClipButton').disabled = false;
                                document.getElementById('screenshotButton').disabled = false;
                            }
                        } else {
                            console.warn("Offer message received without offer data", message);
                        }
                        break;
                    case 'candidate':
                        if (peerConnection && message.candidate) {
                            if (peerConnection.remoteDescription) {
                                try {
                                    await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                                    console.log('Added remote ICE candidate (viewer).');
                                } catch (e) {
                                    console.error('Error adding received ICE candidate (viewer):', e);
                                }
                            } else {
                                console.warn('Received ICE candidate (viewer) but remote description not set yet.');
                            }
                        }
                        break;
                    case 'recovery_attempt':
                        updateConnectionStatus('connecting', 'Initiator is attempting to recover connection...');
                        
                        // Reset timeout since initiator is actively working on it
                        if (reconnectTimeoutId) {
                            clearTimeout(reconnectTimeoutId);
                            reconnectTimeoutId = setTimeout(() => {
                                if (isReconnecting && peerConnection && 
                                    (peerConnection.iceConnectionState !== 'connected' && 
                                     peerConnection.iceConnectionState !== 'completed')) {
                                    updateConnectionStatus('disconnected', 'Recovery attempt timed out.');
                                }
                            }, RECONNECT_TIMEOUT);
                        }
                        break;
                    case 'hangup':
                        console.log('Received hangup from initiator/server (viewer)');
                        updateConnectionStatus('disconnected', 'Stream ended by initiator.');
                        stopViewing(false);
                        break;
                    case 'pong':
                        console.log('Received pong from server (viewer) - connection alive');
                        break;
                    case 'error':
                        updateConnectionStatus('disconnected', `Server error: ${message.message}`);
                        console.error('Server error message:', message.message);
                        stopViewing(false);
                        break;
                    case 'session_not_found':
                        updateConnectionStatus('disconnected', `Session ID ${currentSessionId} not found or initiator not connected.`);
                        console.warn(`Session ${currentSessionId} not found or initiator not connected.`);
                        stopViewing(false);
                        break;
                }
            };

            websocket.onerror = (error) => {
                console.error('WebSocket error (viewer):', error);
                updateConnectionStatus('disconnected', 'WebSocket connection error. Please try again.');
                stopViewing(false);
            };

            websocket.onclose = (event) => {
                console.log('WebSocket connection closed (viewer):', event.reason, `Code: ${event.code}`);
                if (keepAliveIntervalId) clearInterval(keepAliveIntervalId);
                if (peerConnection && peerConnection.iceConnectionState !== 'closed') {
                }
            };
        }

        async function joinStream() {
            currentSessionId = document.getElementById('sessionIdInput').value.trim();
            if (!currentSessionId) {
                alert('Please enter a Session ID.');
                return;
            }
            if (peerConnection && peerConnection.iceConnectionState !== 'closed' && peerConnection.iceConnectionState !== 'failed') {
                alert('Already connected or attempting to connect. Please "Stop Viewing" first.');
                return;
            }

            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.onclose = null;
                websocket.close();
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            updateConnectionStatus('connecting', 'Attempting to join stream via WebSocket...');
            reconnectAttempts = 0;
            isReconnecting = false;
            
            connectWebSocketAndJoin();
        }

        async function handleOffer(offer) {
            if (peerConnection) {
                peerConnection.close();
            }
            peerConnection = new RTCPeerConnection(peerConnectionConfig);

            // Add debug tracking
            updateVideoDebugInfo("PeerConnection created, waiting for tracks...");

            peerConnection.ontrack = event => {
                updateVideoDebugInfo(`Track received: ${event.track.kind}`);
                const remoteVideo = document.getElementById('remoteVideo');
                
                // Ensure the video is ready to play
                remoteVideo.onloadedmetadata = () => {
                    updateVideoDebugInfo("Video metadata loaded, attempting to play");
                    remoteVideo.play()
                        .then(() => updateVideoDebugInfo("Video playback started successfully"))
                        .catch(e => {
                            updateVideoDebugInfo(`Error starting video: ${e.message}`);
                            alert('Error playing video. Try clicking on the video to unmute/play.');
                        });
                };

                remoteVideo.onerror = (e) => {
                    updateVideoDebugInfo(`Video element error: ${e.message || 'Unknown error'}`);
                };

                if (event.streams && event.streams[0]) {
                    updateVideoDebugInfo("Using stream from event.streams[0]");
                    remoteVideo.srcObject = event.streams[0];
                    updateConnectionStatus('connected', 'Stream connected successfully!');
                    reconnectAttempts = 0;
                    isReconnecting = false;
                } else if (event.track) {
                    updateVideoDebugInfo("No stream available, creating new MediaStream");
                    if (!remoteVideo.srcObject) {
                        remoteVideo.srcObject = new MediaStream();
                    }
                    remoteVideo.srcObject.addTrack(event.track);
                    updateConnectionStatus('connected', 'Stream connected successfully!');
                    reconnectAttempts = 0;
                    isReconnecting = false;
                }

                // Enable controls once the track is received and video is playing
                remoteVideo.oncanplay = () => {
                    document.getElementById('startClipButton').disabled = false;
                    document.getElementById('screenshotButton').disabled = false;
                    updateVideoDebugInfo('Video can play, media controls enabled.');
                };
            };

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    sendSignalingMessage({ type: 'candidate', candidate: event.candidate });
                    updateVideoDebugInfo("ICE candidate sent to initiator");
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log(`ICE connection state (viewer): ${peerConnection.iceConnectionState}`);
                updateVideoDebugInfo(`ICE connection state: ${peerConnection.iceConnectionState}`);
                
                if (peerConnection.iceConnectionState === 'connected' || peerConnection.iceConnectionState === 'completed') {
                    updateConnectionStatus('connected', 'Stream connected successfully!');
                    reconnectAttempts = 0;
                    isReconnecting = false;
                } else if (peerConnection.iceConnectionState === 'failed') {
                    updateConnectionStatus('disconnected', 'Stream connection failed.');
                    handleConnectionFailure();
                } else if (peerConnection.iceConnectionState === 'disconnected') {
                    updateConnectionStatus('connecting', 'Stream temporarily disconnected. Attempting to recover...');
                } else if (peerConnection.iceConnectionState === 'closed') {
                    updateConnectionStatus('disconnected', 'Stream closed.');
                }
            };

            peerConnection.onsignalingstatechange = () => {
                console.log(`Signaling state (viewer): ${peerConnection.signalingState}`);
            };

            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                console.log('Remote description (offer) set.');
                updateVideoDebugInfo("Remote description (offer) set successfully");

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Local description (answer) created.');
                updateVideoDebugInfo("Local description (answer) created successfully");

                const sendSuccess = sendSignalingMessage({ type: 'answer', answer: answer });
                if (!sendSuccess) {
                    updateConnectionStatus('disconnected', 'Failed to send answer. Please try again.');
                    throw new Error('Failed to send answer via WebSocket.');
                }
            } catch (error) {
                updateVideoDebugInfo(`Error in offer/answer process: ${error.message}`);
                console.error("WebRTC error:", error);
                updateConnectionStatus('disconnected', `WebRTC Error: ${error.message}`);
            }
        }

        function handleConnectionFailure() {
            if (isReconnecting) return;
            
            isReconnecting = true;
            reconnectAttempts++;
            
            if (reconnectAttempts <= MAX_RECONNECT_ATTEMPTS) {
                updateConnectionStatus('connecting', `WebRTC connection failed. Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                
                // Clear any existing timeout
                if (reconnectTimeoutId) {
                    clearTimeout(reconnectTimeoutId);
                }
                
                // Request ICE restart from initiator
                sendSignalingMessage({ type: 'request_ice_restart' });
                console.log("WebRTC connection failed. Viewer is requesting ICE restart.");
                
                // Set timeout for this reconnection attempt
                reconnectTimeoutId = setTimeout(() => {
                    if (isReconnecting && peerConnection && 
                        (peerConnection.iceConnectionState !== 'connected' && 
                         peerConnection.iceConnectionState !== 'completed')) {
                        
                        updateConnectionStatus('disconnected', `Reconnect attempt ${reconnectAttempts} timed out.`);
                        sendSignalingMessage({ type: 'recovery_timeout' });
                        
                        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                            updateConnectionStatus('disconnected', 'Failed to reconnect after multiple attempts.');
                            stopViewing(false);
                        } else {
                            // Try again with a new connection
                            if (peerConnection) {
                                peerConnection.close();
                                peerConnection = null;
                            }
                            // Wait briefly before attempting again
                            setTimeout(() => {
                                isReconnecting = false;
                                handleConnectionFailure();
                            }, 2000);
                        }
                    }
                }, RECONNECT_TIMEOUT);
            } else {
                updateConnectionStatus('disconnected', 'Failed to reconnect WebRTC stream after multiple attempts.');
                console.error('Failed to reconnect WebRTC stream.');
                stopViewing(false);
            }
        }

        function stopViewing(notifyServer = true) {
            if (keepAliveIntervalId) {
                clearInterval(keepAliveIntervalId);
                keepAliveIntervalId = null;
            }

            if (notifyServer && websocket && websocket.readyState === WebSocket.OPEN) {
                sendSignalingMessage({ type: 'hangup' });
                console.log('Sent hangup message via WebSocket (viewer).');
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (websocket) {
                if (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING) {
                    websocket.onclose = null; 
                    websocket.close();
                }
                websocket = null;
            }

            const remoteVideo = document.getElementById('remoteVideo');
            if (remoteVideo) remoteVideo.srcObject = null;
            updateConnectionStatus('disconnected', 'Viewing stopped.');
            document.getElementById('connectionStatus').style.display = 'block';
            isReconnecting = false;
            reconnectAttempts = 0;

            document.getElementById('startClipButton').disabled = true;
            document.getElementById('endClipButton').disabled = true;
            document.getElementById('screenshotButton').disabled = true;
            document.getElementById('clipStatus').textContent = '';
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
            }
        }

        function checkMediaCompatibility() {
            updateVideoDebugInfo(`Browser: ${navigator.userAgent}`);
            if (navigator.mediaDevices) {
                updateVideoDebugInfo("mediaDevices API available");
            } else {
                updateVideoDebugInfo("mediaDevices API NOT available");
            }
            
            if (window.RTCPeerConnection) {
                updateVideoDebugInfo("RTCPeerConnection API available");
            } else {
                updateVideoDebugInfo("RTCPeerConnection API NOT available");
            }
            
            if (window.MediaStream) {
                updateVideoDebugInfo("MediaStream API available");
            } else {
                updateVideoDebugInfo("MediaStream API NOT available");
            }
        }

        // FR008 & FR010: Viewer Live Clipping and Media Controls
        function startClip() {
            const remoteVideo = document.getElementById('remoteVideo');
            if (!remoteVideo.srcObject) {
                alert('Stream not available to start clipping.');
                updateVideoDebugInfo('Attempted to start clip, but no stream available.');
                return;
            }

            if (mediaRecorder && mediaRecorder.state === "recording") {
                alert('Clipping is already in progress.');
                return;
            }

            try {
                const stream = remoteVideo.srcObject;
                recordedChunks = []; // Reset for new clip
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstart = () => {
                    clipStartTime = new Date();
                    document.getElementById('startClipButton').disabled = true;
                    document.getElementById('endClipButton').disabled = false;
                    document.getElementById('screenshotButton').disabled = true; // Disable screenshot during clipping
                    document.getElementById('clipStatus').textContent = 'Clipping in progress...';
                    updateVideoDebugInfo('Clipping started.');
                    console.log('MediaRecorder started, state:', mediaRecorder.state);
                };
                
                mediaRecorder.onstop = () => {
                    document.getElementById('startClipButton').disabled = false;
                    document.getElementById('endClipButton').disabled = true;
                    document.getElementById('screenshotButton').disabled = false; // Re-enable screenshot
                    document.getElementById('clipStatus').textContent = 'Clip captured!';
                    updateVideoDebugInfo('Clipping stopped. Processing data...');
                    console.log('MediaRecorder stopped, state:', mediaRecorder.state);

                    if (recordedChunks.length === 0) {
                        console.warn("No data recorded for the clip.");
                        alert("No data was recorded for the clip. Please try again.");
                        document.getElementById('clipStatus').textContent = 'Clip capture failed (no data).';
                        return;
                    }

                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const clipName = `clip_${new Date().toISOString().replace(/[:.]/g, '-')}.webm`;
                    
                    addMediaToList('clipsList', clipName, url);
                    recordedChunks = []; // Clear for next recording
                    
                    setTimeout(() => {
                        document.getElementById('clipStatus').textContent = '';
                    }, 3000);
                };

                mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                    alert('Error during clipping: ' + event.error.name);
                    document.getElementById('startClipButton').disabled = false;
                    document.getElementById('endClipButton').disabled = true;
                    document.getElementById('screenshotButton').disabled = false;
                    document.getElementById('clipStatus').textContent = 'Clipping error.';
                    updateVideoDebugInfo(`MediaRecorder error: ${event.error.name} - ${event.error.message}`);
                };
                
                mediaRecorder.start();

            } catch (e) {
                console.error('Error starting MediaRecorder:', e);
                alert('Could not start clipping: ' + e.message);
                updateVideoDebugInfo(`Error starting MediaRecorder: ${e.message}`);
                document.getElementById('startClipButton').disabled = false;
                document.getElementById('endClipButton').disabled = true;
                document.getElementById('screenshotButton').disabled = false;
            }
        }

        function endClip() {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            } else {
                alert('Clipping is not in progress.');
                updateVideoDebugInfo('Attempted to end clip, but no recording in progress.');
            }
        }

        // FR009 & FR010: Viewer Screenshot Capture and Media Controls
        function takeScreenshot() {
            const remoteVideo = document.getElementById('remoteVideo');
            if (!remoteVideo.srcObject || remoteVideo.paused || remoteVideo.ended) {
                alert('Video stream not active or available for screenshot.');
                updateVideoDebugInfo('Screenshot attempt failed: Video stream not active.');
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = remoteVideo.videoWidth;
            canvas.height = remoteVideo.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(remoteVideo, 0, 0, canvas.width, canvas.height);

            try {
                const dataUrl = canvas.toDataURL('image/png');
                const screenshotName = `screenshot_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
                
                addMediaToList('screenshotsList', screenshotName, dataUrl);
                
                document.getElementById('clipStatus').textContent = 'Screenshot captured!';
                updateVideoDebugInfo('Screenshot taken.');
                setTimeout(() => {
                    document.getElementById('clipStatus').textContent = '';
                }, 2000);

            } catch (e) {
                console.error('Error taking screenshot:', e);
                alert('Could not take screenshot: ' + e.message);
                updateVideoDebugInfo(`Error taking screenshot: ${e.message}`);
                document.getElementById('clipStatus').textContent = 'Screenshot failed.';
                 setTimeout(() => {
                    document.getElementById('clipStatus').textContent = '';
                }, 2000);
            }
        }

        function addMediaToList(listId, fileName, dataUrl) {
            const listContainer = document.getElementById(listId);
            const list = listContainer.querySelector('ul');
            listContainer.style.display = 'block';

            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = fileName;
            link.textContent = fileName;
            listItem.appendChild(link);
            list.appendChild(listItem);
            updateVideoDebugInfo(`Added ${fileName} to download list.`);
        }

    </script>
</body>
</html>
