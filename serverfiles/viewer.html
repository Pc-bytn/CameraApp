<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Stream Viewer</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        video { border: 1px solid black; max-width: 100%; background-color: #333; }
        input, button { padding: 10px; margin: 5px; font-size: 1em; }
        #connectionStatus {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .connecting { background-color: #FFF3CD; color: #856404; }
        .connected { background-color: #D4EDDA; color: #155724; }
        .disconnected { background-color: #F8D7DA; color: #721C24; }
    </style>
</head>
<body>
    <h1>WebRTC Stream Viewer</h1>
    <div>
        <input type="text" id="sessionIdInput" placeholder="Enter Session ID from App">
        <button onclick="joinStream()">Join Stream</button>
        <button onclick="stopViewing()">Stop Viewing</button>
    </div>
    <div id="connectionStatus" style="display: none;"></div>
    <video id="remoteVideo" autoplay playsinline controls></video>
    
    <script src="PRIVATE_URL.JS"></script>
    <script>
        let peerConnection;
        const signalingServerUrl = window.SIGNALING_SERVER_URL; // IMPORTANT: Replace with your actual PHP server URL
        let currentSessionId;
        let signalingPollIntervalId;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 3;
        let isReconnecting = false;

        // Check for sessionId in URL parameters
        document.addEventListener('DOMContentLoaded', function() {
            const urlParams = new URLSearchParams(window.location.search);
            const sessionIdFromUrl = urlParams.get('sessionId');
            if (sessionIdFromUrl) {
                document.getElementById('sessionIdInput').value = sessionIdFromUrl;
                // Optionally auto-join the stream if a sessionId is provided
                joinStream();
            }
        });

        const peerConnectionConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                // Add free TURN servers for better connectivity
                {
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:openrelay.metered.ca:443',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ],
            iceCandidatePoolSize: 10
        };

        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.style.display = 'block';
            statusElement.textContent = message;
            statusElement.className = status;
        }

        async function sendSignalingMessage(message) {
            try {
                // When viewer sends, it's for the initiator
                const response = await fetch(`${signalingServerUrl}?action=send&sessionId=${message.sessionId}`, { // Pass sessionId in query
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(message),
                });
                if (!response.ok) {
                    throw new Error(`Signaling server error: ${response.status} ${await response.text()}`);
                }
                console.log('Signaling message sent (viewer):', message.type);
            } catch (e) {
                console.error('Send signaling error (viewer):', e);
                updateConnectionStatus('disconnected', `Error sending signaling message: ${e.message}`);
                return false;
            }
            return true;
        }

        async function listenForSignalingMessages(sessionId) {
            if (signalingPollIntervalId) {
                clearInterval(signalingPollIntervalId);
            }
            
            signalingPollIntervalId = setInterval(async () => {
                if (!peerConnection || peerConnection.signalingState === 'closed') {
                    clearInterval(signalingPollIntervalId);
                    return;
                }
                try {
                    // 'viewer' tells the server we are the one viewing the stream
                    const response = await fetch(`${signalingServerUrl}?action=receive&sessionId=${sessionId}&peer=viewer`);
                    if (response.ok) {
                        const message = await response.json();
                        if (message) {
                            console.log('Received signaling message (viewer):', message);
                            if (message.type === 'offer') { // Should have already received this to initiate joinStream
                                console.warn("Received offer again, already processed or should be initial fetch.");
                            } else if (message.type === 'candidate' && message.candidate) {
                                if (peerConnection.remoteDescription) { // Ensure offer (remote desc) is set
                                    try {
                                        await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                                        console.log('Added remote ICE candidate (from initiator).');
                                    } catch (e) {
                                        console.error('Error adding received ICE candidate (viewer):', e);
                                    }
                                } else {
                                     console.warn('Received ICE candidate but remote description (offer) not set yet.');
                                }
                            } else if (message.type === 'ping') {
                                // Send pong response to keep connection alive
                                sendSignalingMessage({ type: 'pong', sessionId: currentSessionId });
                            }
                        }
                    } else if (response.status !== 404) {
                         console.error('Error fetching signaling messages (viewer):', response.status, await response.text());
                    }
                } catch (e) {
                    // console.warn('Polling error (viewer - can be normal if no messages):', e.message);
                }
            }, 1000); // More frequent polling to catch messages quickly
        }

        async function joinStream() {
            currentSessionId = document.getElementById('sessionIdInput').value.trim();
            if (!currentSessionId) {
                alert('Please enter a Session ID.');
                return;
            }
            if (peerConnection && peerConnection.iceConnectionState !== 'closed' && peerConnection.iceConnectionState !== 'failed') {
                alert('Already connected or attempting to connect. Please "Stop Viewing" first.');
                return;
            }

            updateConnectionStatus('connecting', 'Attempting to join stream...');
            reconnectAttempts = 0;
            isReconnecting = false;
            
            try {
                await initiateConnection();
            } catch (e) {
                updateConnectionStatus('disconnected', `Error joining stream: ${e.message}`);
                console.error('Join Stream Error:', e);
                stopViewing();
            }
        }

        async function initiateConnection() {
            let offerFound = false;
            let maxWaitMs = 30000; // 30 seconds
            let pollIntervalMs = 2000;
            let waitedMs = 0;
            let offerMessage = null;

            updateConnectionStatus('connecting', 'Waiting for stream to start...');
            
            // --- Fix: Always fetch the latest offer, and ignore partial/invalid offers ---
            while (!offerFound && waitedMs < maxWaitMs) {
                try {
                    const offerResponse = await fetch(`${signalingServerUrl}?action=receive&sessionId=${currentSessionId}&peer=viewer`);
                    if (offerResponse.ok) {
                        const message = await offerResponse.json();
                        // Only accept if message is a valid offer and has a valid SDP
                        if (message && message.type === 'offer' && message.offer && message.offer.sdp) {
                            offerFound = true;
                            offerMessage = message;
                            break;
                        }
                    }
                } catch (e) {
                    // Ignore fetch errors during polling
                }
                if (!offerFound) {
                    await new Promise(res => setTimeout(res, pollIntervalMs));
                    waitedMs += pollIntervalMs;
                }
            }
            if (!offerFound) {
                throw new Error('No offer found for this session ID after waiting. Ensure the app has started streaming.');
            }

            // 2. Create RTCPeerConnection
            if (peerConnection) {
                peerConnection.close();
            }
            peerConnection = new RTCPeerConnection(peerConnectionConfig);

            // 3. Handle incoming tracks from the Cordova app
            peerConnection.ontrack = event => {
                const remoteVideo = document.getElementById('remoteVideo');
                remoteVideo.muted = true; // Allow autoplay in most browsers
                if (event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.play().catch(e => {
                        console.warn('Autoplay failed:', e);
                        updateConnectionStatus('connected', 'Stream connected. Click video to play.');
                    });
                    console.log('Remote stream added to video element.');
                    updateConnectionStatus('connected', 'Stream connected successfully!');
                } else {
                    // Fallback for older browsers
                    if (!remoteVideo.srcObject && event.track) {
                        let inboundStream = new MediaStream();
                        inboundStream.addTrack(event.track);
                        remoteVideo.srcObject = inboundStream;
                        remoteVideo.play().catch(e => {
                            console.warn('Autoplay failed (fallback):', e);
                            updateConnectionStatus('connected', 'Stream connected. Click video to play.');
                        });
                        console.log('Remote track added to video element (fallback).');
                        updateConnectionStatus('connected', 'Stream connected successfully!');
                    }
                }
            };

            // 4. Handle ICE candidates
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    sendSignalingMessage({ type: 'candidate', candidate: event.candidate, sessionId: currentSessionId });
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log(`ICE connection state (viewer): ${peerConnection.iceConnectionState}`);
                
                if (peerConnection.iceConnectionState === 'connected' || peerConnection.iceConnectionState === 'completed') {
                    isReconnecting = false;
                    reconnectAttempts = 0;
                    updateConnectionStatus('connected', 'Stream connected successfully!');
                } else if (peerConnection.iceConnectionState === 'failed') {
                    updateConnectionStatus('disconnected', 'Stream connection failed. Attempting to reconnect...');
                    handleConnectionFailure();
                } else if (peerConnection.iceConnectionState === 'disconnected') {
                    updateConnectionStatus('disconnected', 'Stream temporarily disconnected. Waiting for reconnection...');
                    // Wait a bit to see if it auto-recovers before trying to reconnect
                    setTimeout(() => {
                        if (peerConnection && peerConnection.iceConnectionState === 'disconnected') {
                            handleConnectionFailure();
                        }
                    }, 5000);
                } else if (peerConnection.iceConnectionState === 'closed') {
                    updateConnectionStatus('disconnected', 'Stream closed.');
                    stopViewing();
                }
            };
            
            peerConnection.onsignalingstatechange = () => {
                console.log(`Signaling state (viewer): ${peerConnection.signalingState}`);
            };

            // 5. Set the received offer as the remote description
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offerMessage.offer));
            console.log('Remote description (offer) set.');

            // 6. Create an SDP answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            console.log('Local description (answer) created.');

            // 7. Send the answer to the signaling server (for the Cordova app)
            const sendSuccess = await sendSignalingMessage({ type: 'answer', answer: answer, sessionId: currentSessionId });
            if (!sendSuccess) {
                throw new Error('Failed to send answer to signaling server');
            }

            // 8. Start listening for candidates from the Cordova app
            listenForSignalingMessages(currentSessionId);
        }

        async function handleConnectionFailure() {
            if (isReconnecting) return;
            
            isReconnecting = true;
            
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                updateConnectionStatus('connecting', `Connection lost. Reconnecting... (Attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                
                try {
                    await initiateConnection();
                } catch (e) {
                    console.error('Reconnection attempt failed:', e);
                    updateConnectionStatus('disconnected', `Reconnection failed: ${e.message}`);
                    
                    // Try again after a delay
                    setTimeout(() => {
                        isReconnecting = false;
                        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                            handleConnectionFailure();
                        } else {
                            updateConnectionStatus('disconnected', 'Failed to reconnect after multiple attempts.');
                            stopViewing();
                        }
                    }, 3000);
                }
            } else {
                updateConnectionStatus('disconnected', 'Failed to reconnect after multiple attempts.');
                stopViewing();
            }
        }

        function stopViewing() {
            if (signalingPollIntervalId) {
                clearInterval(signalingPollIntervalId);
                signalingPollIntervalId = null;
            }
            if (peerConnection) {
                // Send a hangup message to inform the other side
                if (currentSessionId) {
                    sendSignalingMessage({ type: 'hangup', sessionId: currentSessionId });
                }
                peerConnection.close();
                peerConnection = null;
            }
            const remoteVideo = document.getElementById('remoteVideo');
            if (remoteVideo) remoteVideo.srcObject = null;
            currentSessionId = null;
            updateConnectionStatus('disconnected', 'Viewing stopped.');
            isReconnecting = false;
            reconnectAttempts = 0;
        }
    </script>
</body>
</html>
